train_accuracy: 0.5
test_accuracy: 0.0
optimized ruleset_4:
- Make the smallest, most localized change that addresses the issue; modify the correct layer/entry-point (method/class) where the behavior is defined rather than adding wrappers or unrelated helpers.
- Mirror established patterns and conventions in the codebase (naming, logging style, repr/str formatting, id_for_label semantics, backend-specific overrides like as_sqlite()/as_oracle()) to maintain compatibility with existing tests and style.
- When changing error messages, include required placeholders and pass params so messages render exactly as expected; do not rephrase messages or change punctuation/quoting styles used across the codebase.
- Do not add demonstration scripts, debug files, or extraneous modules; only modify production code and, when appropriate, existing tests relevant to the change. Do not create new test files unless explicitly required by the provided test patch.
- Prefer reusing existing helpers/utilities (e.g., HasKey, get_email_field_name(), deconstruct()) instead of reimplementing logic; when cloning complex objects (like Q), prefer deconstruct()/reconstruct over deepcopy to avoid copying unpickleable objects.
- Normalize non-pickleable, iterator-like values (e.g., dict_keys, dict_values, dict_items) to concrete types during deconstruction/serialization or resolution paths; when reconstructing iterables from resolved lookup values, preserve the original container type and detect namedtuples via _make/_fields or attribute presence, unpacking with *values.
- For exec/evaluation contexts, provide the appropriate globals() (not an empty dict) to allow access to imports and module globals while executing dynamic code.
- When handling Q/combinator logic, support combining with conditional expressions (objects exposing conditional=True) by accepting and/or wrapping them; when cloning/combining with empty Q, reconstruct from deconstruct() rather than deepcopy; implement commutative behavior (e.g., __rand__/__ror__) where appropriate.
- For combined query operations, enforce unsupported operations early with clear errors (e.g., distinct() on UNION/INTERSECT/EXCEPT); propagate “empty” state to combined queries and short-circuit execution (e.g., raise EmptyResultSet) when appropriate; ensure .none() on combined queries returns no results.
- For database/backend-specific behavior, use the correct backend hooks and SQL helpers; ensure lookups distinguish between missing keys and explicit JSON nulls, following backend primitives (e.g., JSON_TYPE on SQLite, composite predicates on Oracle).
- When reordering operations (e.g., migrations), prefer adjusting generation order rather than bolting on complex dependencies; ensure operations that depend on synthesized fields (e.g., _order) are generated after AlterOrderWithRespectTo creates them.
- Validate and normalize inputs early (e.g., expand user paths, absolutize, and strip trailing path separators before os.path.basename) so downstream logic receives canonical values.
- Ensure subclass/instance checks for metaclasses honor inheritance of known subclasses and their subclasses (e.g., use issubclass against a tuple of supported subclasses) so custom subclasses pass framework checks.
- Keep repr/str outputs aligned with existing formatting (correct quoting and route/url_name formatting); when displaying wrapped callables (e.g., functools.partial), match project expectations for repr while preserving self.func unchanged (e.g., include repr(self.func) in __repr__ but compute view_name from the unwrapped underlying callable).
- Avoid broad behavior changes that alter public APIs or cached behavior beyond the scope of the fix; keep diffs minimal and targeted to the reported issue.
- For widget labeling, return None from id_for_label when the widget renders no labelable element; for subwidgets, prefer IDs supplied via attrs (e.g., ChoiceWidget.options) over reconstructed IDs.
- When extending token/hash generation with additional fields (e.g., email), use model APIs (e.g., get_email_field_name()), handle None safely, and preserve backward compatibility where required (e.g., accept legacy tokens).
- When adding logging around error-swallowing code paths (e.g., send_robust, session decoding fallbacks), use the project’s logger name and format; include exc_info with the actual exception object; don’t modify control flow beyond logging and returning safe defaults (e.g., on BadSignature/base64 errors, fall back to legacy decode and return an empty session if necessary). Prefer using established security loggers (e.g., django.security.SuspiciousSession) and stable messages when applicable.
- For combined group-by/annotation generation, avoid ambiguous aliases; if an annotation alias collides with joined column names, group by the full expression instead of the alias.
- In ForeignKey assignment, when the related object’s PK is set after assignment, update the FK field when its value is in field.empty_values (not just None) to reflect the related object’s saved primary key.
- In Management/CLI code, ensure parsers are instantiated with the computed program name (prog) rather than relying on sys.argv; preserve consistent help/usage output across environments. If an internal method is promoted to public, keep a backward-compatible alias delegating to the new method.
- For ordering across relationships, base comparisons on the final path component (e.g., pieces[-1]) and avoid injecting related model default ordering when ordering by pk or an explicit attribute/attname; preserve requested ASC/DESC.
- When validating model default PK configuration, do not warn on child models inheriting a parent_link OneToOneField primary key; only warn on truly auto-created PKs lacking explicit configuration.
- For form/field validation, include the offending value in invalid_choice errors via params (e.g., {'value': value}); for model instances, include a useful scalar (e.g., pk) in the message where applicable.
- When serializing Enums in migrations, reference members by name (e.g., MyEnum['A']) rather than by value to avoid breakage from translated or changed values; preserve callables in migration state and only resolve at runtime where intended.
- To prevent duplicate rows introduced by joins in choice-restricting filters (e.g., limit_choices_to), prefer correlated subqueries with Exists/OuterRef over plain join-based filters; do not rely on distinct() as a workaround.
- For async-capable handlers (e.g., ASGI), provide async equivalents of sync methods (e.g., get_response_async) using sync_to_async; maintain thread safety (thread_sensitive=True) when interacting with Django internals or threadlocals.
- When comparing/ordering framework Field instances (e.g., for abstract model inheritance), include both creation_counter and model identity (app_label, model_name) in equality, ordering, and hashing to avoid collisions across models.
- In autoreload or filesystem scanning code, defensively handle OS/path resolution errors (e.g., ValueError due to embedded null bytes) by skipping problematic paths and logging at debug level instead of raising.
- Prioritize fixing behavior in production code; only modify tests when the test patch explicitly requires changes. Don’t add new tests or utilities beyond those indicated; never replace a production change with test-only changes.
- When decoding or verifying untrusted data (e.g., base64, signed values), guard all exceptions, prefer returning safe defaults (e.g., empty sessions), and log at appropriate security loggers with clear, consistent messages.
